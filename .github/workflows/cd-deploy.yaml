name: CD - Deploy Model

on:
  workflow_run:
    workflows: ["CI - Test Model"]
    types: [ completed ]
    branches: [ main ]

env:
  ECR_REPOSITORY: ml-model-california-housing
  AWS_REGION: ap-northeast-2

jobs:
  deploy:
    name: Build and Deploy Model
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # ============================================================
      # ðŸ†• ECR Repository ìƒì„± (ì¡´ìž¬í•˜ì§€ ì•Šì„ ê²½ìš°)
      # ============================================================
      - name: Create ECR Repository if not exists
        env:
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
        run: |
          echo "ðŸ” Checking if ECR repository exists..."
          
          # ECR Repository ì¡´ìž¬ ì—¬ë¶€ í™•ì¸
          if aws ecr describe-repositories --repository-names $ECR_REPOSITORY 2>/dev/null; then
            echo "âœ… ECR repository '$ECR_REPOSITORY' already exists"
          else
            echo "ðŸ“¦ Creating ECR repository '$ECR_REPOSITORY'..."
            aws ecr create-repository \
              --repository-name $ECR_REPOSITORY \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE \
              --encryption-configuration encryptionType=AES256
            
            echo "âœ… ECR repository created successfully"
            
            # Lifecycle Policy ì„¤ì • (ì„ íƒì‚¬í•­ - ì´ë¯¸ì§€ ì •ë¦¬)
            echo "ðŸ“‹ Setting lifecycle policy..."
            aws ecr put-lifecycle-policy \
              --repository-name $ECR_REPOSITORY \
              --lifecycle-policy-text '{
                "rules": [
                  {
                    "rulePriority": 1,
                    "description": "Keep last 10 images",
                    "selection": {
                      "tagStatus": "any",
                      "countType": "imageCountMoreThan",
                      "countNumber": 10
                    },
                    "action": {
                      "type": "expire"
                    }
                  }
                ]
              }'
            echo "âœ… Lifecycle policy configured"
          fi

      - name: Set image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          echo "tag=v$(date +%Y%m%d)-${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT

      - name: Check if Dockerfile exists
        id: check-dockerfile
        run: |
          if [ -f "Dockerfile" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Dockerfile found in repository"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  Dockerfile not found - will generate automatically"
          fi
      
      - name: Generate Dockerfile (if not exists)
        if: steps.check-dockerfile.outputs.exists == 'false'
        run: |
          echo "ðŸ“ Generating application files for California Housing model..."
          
          # Create api.py
          cat > api.py << 'APIEOF'
          from fastapi import FastAPI, HTTPException
          from pydantic import BaseModel, Field
          from typing import List
          import numpy as np
          from sklearn.datasets import fetch_california_housing
          from sklearn.ensemble import RandomForestRegressor
          from sklearn.model_selection import train_test_split
          import logging
          import os
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger(__name__)
          
          app = FastAPI(
              title="California Housing Model API",
              description="ML model for California Housing price prediction",
              version=os.getenv("MODEL_VERSION", "1.0.0")
          )
          
          class PredictionInput(BaseModel):
              features: List[float] = Field(..., min_items=8, max_items=8)
          
          class PredictionOutput(BaseModel):
              prediction: float
              model_version: str
          
          # Global model
          model = None
          
          @app.on_event("startup")
          async def load_model():
              global model
              logger.info("Loading model...")
              data = fetch_california_housing()
              X_train, _, y_train, _ = train_test_split(
                  data.data, data.target, test_size=0.2, random_state=42
              )
              model = RandomForestRegressor(n_estimators=100, random_state=42, n_jobs=-1)
              model.fit(X_train, y_train)
              logger.info("Model loaded successfully")
          
          @app.get("/health")
          async def health():
              return {"status": "healthy", "model_loaded": model is not None}
          
          @app.post("/predict", response_model=PredictionOutput)
          async def predict(input_data: PredictionInput):
              if model is None:
                  raise HTTPException(status_code=503, detail="Model not loaded")
              features = np.array(input_data.features).reshape(1, -1)
              prediction = model.predict(features)[0]
              return PredictionOutput(
                  prediction=float(prediction),
                  model_version=os.getenv("MODEL_VERSION", "1.0.0")
              )
          APIEOF
          
          # Create Dockerfile
          cat > Dockerfile << 'DOCKEREOF'
          FROM python:3.9-slim
          WORKDIR /app
          RUN pip install --no-cache-dir fastapi uvicorn scikit-learn numpy pydantic
          COPY api.py .
          ENV MODEL_VERSION=1.0.0
          EXPOSE 8080
          CMD ["uvicorn", "api:app", "--host", "0.0.0.0", "--port", "8080"]
          DOCKEREOF
          
          echo "âœ… Generated api.py and Dockerfile"

      - name: Build Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          echo "ðŸ”¨ Building Docker image..."
          docker build --platform linux/amd64 \
            --build-arg MODEL_VERSION=$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            .
          echo "âœ… Image built: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Push image to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "âœ… Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - name: Check Kubernetes configuration
        id: check-k8s
        run: |
          if [ -n "${{ secrets.KUBECONFIG_DATA }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
            echo "âœ… Kubernetes configuration available"
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  KUBECONFIG_DATA not configured - skipping K8s deployment"
          fi

      - name: Set up kubectl
        if: steps.check-k8s.outputs.configured == 'true'
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Install aws-iam-authenticator
        if: steps.check-k8s.outputs.configured == 'true'
        run: |
          echo "ðŸ“¦ Installing aws-iam-authenticator..."
          curl -Lo aws-iam-authenticator https://github.com/kubernetes-sigs/aws-iam-authenticator/releases/download/v0.6.11/aws-iam-authenticator_0.6.11_linux_amd64
          chmod +x ./aws-iam-authenticator
          sudo mv ./aws-iam-authenticator /usr/local/bin/
          aws-iam-authenticator version
          echo "âœ… aws-iam-authenticator installed"

      - name: Configure kubectl
        if: steps.check-k8s.outputs.configured == 'true'
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          echo "âœ… kubectl configured"

      - name: Deploy to KServe
        if: steps.check-k8s.outputs.configured == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
          NAMESPACE: ${{ secrets.KSERVE_NAMESPACE || 'kubeflow-user01' }}
        run: |
          echo "ðŸš€ Deploying to KServe..."
          
          # InferenceService YAML ìƒì„±
          cat > inferenceservice.yaml << EOF
          apiVersion: serving.kserve.io/v1beta1
          kind: InferenceService
          metadata:
            name: california-housing-predictor
            namespace: $NAMESPACE
            annotations:
              sidecar.istio.io/inject: "false"
          spec:
            predictor:
              minReplicas: 1
              maxReplicas: 3
              containers:
                - name: predictor
                  image: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
                  ports:
                    - containerPort: 8080
                      protocol: TCP
                  env:
                    - name: MODEL_VERSION
                      value: "$IMAGE_TAG"
                  resources:
                    requests:
                      cpu: "100m"
                      memory: "256Mi"
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: 8080
                    initialDelaySeconds: 60
                    periodSeconds: 30
                    timeoutSeconds: 5
                    failureThreshold: 3
          EOF
          
          kubectl apply -f inferenceservice.yaml
          echo "âœ… InferenceService applied"

      # ============================================================
      # ðŸ†• Pod Ready ìƒíƒœ ëŒ€ê¸° (í•µì‹¬ ìˆ˜ì • ì‚¬í•­)
      # ============================================================
      - name: Wait for Pod to be Ready
        if: steps.check-k8s.outputs.configured == 'true'
        env:
          NAMESPACE: ${{ secrets.KSERVE_NAMESPACE || 'kubeflow-user01' }}
        run: |
          echo "â³ Waiting for InferenceService to be ready..."
          
          MAX_RETRIES=30
          RETRY_INTERVAL=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # InferenceService Ready ìƒíƒœ í™•ì¸
            READY=$(kubectl get inferenceservice california-housing-predictor \
              -n $NAMESPACE \
              -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "")
            
            if [ "$READY" = "True" ]; then
              echo "âœ… InferenceService is Ready!"
              break
            fi
            
            # Pod ìƒíƒœ ìƒì„¸ í™•ì¸
            echo "ðŸ“Š Current Pod status:"
            kubectl get pods -n $NAMESPACE -l serving.kserve.io/inferenceservice=california-housing-predictor \
              --no-headers 2>/dev/null || echo "  No pods found yet"
            
            # Podê°€ Pending ìƒíƒœì¸ ê²½ìš° ì›ì¸ í™•ì¸
            POD_NAME=$(kubectl get pods -n $NAMESPACE \
              -l serving.kserve.io/inferenceservice=california-housing-predictor \
              -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            
            if [ -n "$POD_NAME" ]; then
              POD_STATUS=$(kubectl get pod $POD_NAME -n $NAMESPACE -o jsonpath='{.status.phase}' 2>/dev/null || echo "Unknown")
              echo "  Pod: $POD_NAME - Status: $POD_STATUS"
              
              if [ "$POD_STATUS" = "Pending" ]; then
                echo "  ðŸ“‹ Pending reason:"
                kubectl describe pod $POD_NAME -n $NAMESPACE 2>/dev/null | grep -A 5 "Events:" | tail -3 || true
              fi
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "  Retry $RETRY_COUNT/$MAX_RETRIES - waiting ${RETRY_INTERVAL}s..."
            sleep $RETRY_INTERVAL
          done
          
          if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
            echo "âŒ Timeout waiting for InferenceService to be ready"
            echo "ðŸ“‹ Final Pod status:"
            kubectl get pods -n $NAMESPACE -l serving.kserve.io/inferenceservice=california-housing-predictor
            echo "ðŸ“‹ Pod events:"
            kubectl describe pods -n $NAMESPACE -l serving.kserve.io/inferenceservice=california-housing-predictor | tail -30
            exit 1
          fi

      # ============================================================
      # ðŸ†• Health Check ê°œì„  (Pod Ready í›„ ì‹¤í–‰)
      # ============================================================
      - name: Test model endpoint
        if: steps.check-k8s.outputs.configured == 'true'
        env:
          NAMESPACE: ${{ secrets.KSERVE_NAMESPACE || 'kubeflow-user01' }}
        run: |
          echo "ðŸ§ª Testing model endpoint..."
          
          # Pod ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
          POD_NAME=$(kubectl get pods -n $NAMESPACE \
            -l serving.kserve.io/inferenceservice=california-housing-predictor \
            -o jsonpath='{.items[0].metadata.name}')
          
          if [ -z "$POD_NAME" ]; then
            echo "âŒ No pod found for InferenceService"
            exit 1
          fi
          
          echo "Pod: $POD_NAME"
          
          # Podê°€ Running ìƒíƒœì¸ì§€ ìµœì¢… í™•ì¸
          POD_STATUS=$(kubectl get pod $POD_NAME -n $NAMESPACE -o jsonpath='{.status.phase}')
          if [ "$POD_STATUS" != "Running" ]; then
            echo "âŒ Pod is not running. Current status: $POD_STATUS"
            kubectl describe pod $POD_NAME -n $NAMESPACE | tail -20
            exit 1
          fi
          
          # Containerê°€ Ready ìƒíƒœì¸ì§€ í™•ì¸
          CONTAINER_READY=$(kubectl get pod $POD_NAME -n $NAMESPACE \
            -o jsonpath='{.status.containerStatuses[0].ready}')
          
          if [ "$CONTAINER_READY" != "true" ]; then
            echo "â³ Waiting for container to be ready..."
            kubectl wait --for=condition=Ready pod/$POD_NAME -n $NAMESPACE --timeout=120s
          fi
          
          echo "Setting up port-forward for testing..."
          kubectl port-forward -n $NAMESPACE pod/$POD_NAME 8000:8080 &
          PORT_FORWARD_PID=$!
          
          # port-forwardê°€ ì„¤ì •ë  ë•Œê¹Œì§€ ëŒ€ê¸°
          sleep 10
          
          # Health Check ìž¬ì‹œë„ ë¡œì§
          MAX_HEALTH_RETRIES=5
          HEALTH_RETRY_COUNT=0
          
          while [ $HEALTH_RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; do
            echo "Testing /health endpoint (attempt $((HEALTH_RETRY_COUNT + 1))/$MAX_HEALTH_RETRIES)..."
            
            HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
            
            if [ "$HEALTH_RESPONSE" = "200" ]; then
              echo "âœ… Health check passed!"
              curl -s http://localhost:8000/health | jq . || true
              break
            fi
            
            HEALTH_RETRY_COUNT=$((HEALTH_RETRY_COUNT + 1))
            if [ $HEALTH_RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; then
              echo "  Health check returned $HEALTH_RESPONSE, retrying in 5s..."
              sleep 5
            fi
          done
          
          # Cleanup port-forward
          kill $PORT_FORWARD_PID 2>/dev/null || true
          
          if [ "$HEALTH_RESPONSE" != "200" ]; then
            echo "âŒ Health check failed after $MAX_HEALTH_RETRIES attempts"
            echo "ðŸ“‹ Pod logs:"
            kubectl logs $POD_NAME -n $NAMESPACE --tail=50 || true
            exit 1
          fi
          
          echo "âœ… Model deployment verified successfully!"

      - name: Generate deployment summary
        if: always()
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Timestamp | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY

      - name: Deployment instructions (if K8s not configured)
        if: steps.check-k8s.outputs.configured == 'false'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          echo ""
          echo "============================================================"
          echo "ðŸ“¦ Image successfully pushed to ECR!"
          echo "============================================================"
          echo ""
          echo "To deploy manually to KServe:"
          echo ""
          echo "1. Configure KUBECONFIG_DATA secret in GitHub repository"
          echo "2. Ensure KServe is installed in your cluster"
          echo "3. Set KSERVE_NAMESPACE secret (default: kubeflow-user01)"
          echo ""
          echo "Or deploy manually with:"
          echo "  kubectl apply -f inferenceservice.yaml"
          echo ""
          echo "ðŸ’¡ For Lab 3-2, the monitoring stack is the main focus."
          echo "   KServe deployment is an optional advanced feature."
